// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  billing: (where?: BillingWhereInput) => Promise<boolean>;
  order: (where?: OrderWhereInput) => Promise<boolean>;
  phone: (where?: PhoneWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  purchase: (where?: PurchaseWhereInput) => Promise<boolean>;
  shipping: (where?: ShippingWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  billing: (where: BillingWhereUniqueInput) => BillingNullablePromise;
  billings: (args?: {
    where?: BillingWhereInput;
    orderBy?: BillingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Billing>;
  billingsConnection: (args?: {
    where?: BillingWhereInput;
    orderBy?: BillingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BillingConnectionPromise;
  order: (where: OrderWhereUniqueInput) => OrderNullablePromise;
  orders: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Order>;
  ordersConnection: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrderConnectionPromise;
  phone: (where: PhoneWhereUniqueInput) => PhoneNullablePromise;
  phones: (args?: {
    where?: PhoneWhereInput;
    orderBy?: PhoneOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Phone>;
  phonesConnection: (args?: {
    where?: PhoneWhereInput;
    orderBy?: PhoneOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PhoneConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductNullablePromise;
  products: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Product>;
  productsConnection: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductConnectionPromise;
  purchase: (where: PurchaseWhereUniqueInput) => PurchaseNullablePromise;
  purchases: (args?: {
    where?: PurchaseWhereInput;
    orderBy?: PurchaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Purchase>;
  purchasesConnection: (args?: {
    where?: PurchaseWhereInput;
    orderBy?: PurchaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PurchaseConnectionPromise;
  shipping: (where: ShippingWhereUniqueInput) => ShippingNullablePromise;
  shippings: (args?: {
    where?: ShippingWhereInput;
    orderBy?: ShippingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Shipping>;
  shippingsConnection: (args?: {
    where?: ShippingWhereInput;
    orderBy?: ShippingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ShippingConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createBilling: (data: BillingCreateInput) => BillingPromise;
  updateBilling: (args: {
    data: BillingUpdateInput;
    where: BillingWhereUniqueInput;
  }) => BillingPromise;
  updateManyBillings: (args: {
    data: BillingUpdateManyMutationInput;
    where?: BillingWhereInput;
  }) => BatchPayloadPromise;
  upsertBilling: (args: {
    where: BillingWhereUniqueInput;
    create: BillingCreateInput;
    update: BillingUpdateInput;
  }) => BillingPromise;
  deleteBilling: (where: BillingWhereUniqueInput) => BillingPromise;
  deleteManyBillings: (where?: BillingWhereInput) => BatchPayloadPromise;
  createOrder: (data: OrderCreateInput) => OrderPromise;
  updateOrder: (args: {
    data: OrderUpdateInput;
    where: OrderWhereUniqueInput;
  }) => OrderPromise;
  updateManyOrders: (args: {
    data: OrderUpdateManyMutationInput;
    where?: OrderWhereInput;
  }) => BatchPayloadPromise;
  upsertOrder: (args: {
    where: OrderWhereUniqueInput;
    create: OrderCreateInput;
    update: OrderUpdateInput;
  }) => OrderPromise;
  deleteOrder: (where: OrderWhereUniqueInput) => OrderPromise;
  deleteManyOrders: (where?: OrderWhereInput) => BatchPayloadPromise;
  createPhone: (data: PhoneCreateInput) => PhonePromise;
  updatePhone: (args: {
    data: PhoneUpdateInput;
    where: PhoneWhereUniqueInput;
  }) => PhonePromise;
  updateManyPhones: (args: {
    data: PhoneUpdateManyMutationInput;
    where?: PhoneWhereInput;
  }) => BatchPayloadPromise;
  upsertPhone: (args: {
    where: PhoneWhereUniqueInput;
    create: PhoneCreateInput;
    update: PhoneUpdateInput;
  }) => PhonePromise;
  deletePhone: (where: PhoneWhereUniqueInput) => PhonePromise;
  deleteManyPhones: (where?: PhoneWhereInput) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (args: {
    data: ProductUpdateInput;
    where: ProductWhereUniqueInput;
  }) => ProductPromise;
  updateManyProducts: (args: {
    data: ProductUpdateManyMutationInput;
    where?: ProductWhereInput;
  }) => BatchPayloadPromise;
  upsertProduct: (args: {
    where: ProductWhereUniqueInput;
    create: ProductCreateInput;
    update: ProductUpdateInput;
  }) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createPurchase: (data: PurchaseCreateInput) => PurchasePromise;
  updatePurchase: (args: {
    data: PurchaseUpdateInput;
    where: PurchaseWhereUniqueInput;
  }) => PurchasePromise;
  updateManyPurchases: (args: {
    data: PurchaseUpdateManyMutationInput;
    where?: PurchaseWhereInput;
  }) => BatchPayloadPromise;
  upsertPurchase: (args: {
    where: PurchaseWhereUniqueInput;
    create: PurchaseCreateInput;
    update: PurchaseUpdateInput;
  }) => PurchasePromise;
  deletePurchase: (where: PurchaseWhereUniqueInput) => PurchasePromise;
  deleteManyPurchases: (where?: PurchaseWhereInput) => BatchPayloadPromise;
  createShipping: (data: ShippingCreateInput) => ShippingPromise;
  updateShipping: (args: {
    data: ShippingUpdateInput;
    where: ShippingWhereUniqueInput;
  }) => ShippingPromise;
  updateManyShippings: (args: {
    data: ShippingUpdateManyMutationInput;
    where?: ShippingWhereInput;
  }) => BatchPayloadPromise;
  upsertShipping: (args: {
    where: ShippingWhereUniqueInput;
    create: ShippingCreateInput;
    update: ShippingUpdateInput;
  }) => ShippingPromise;
  deleteShipping: (where: ShippingWhereUniqueInput) => ShippingPromise;
  deleteManyShippings: (where?: ShippingWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  billing: (
    where?: BillingSubscriptionWhereInput
  ) => BillingSubscriptionPayloadSubscription;
  order: (
    where?: OrderSubscriptionWhereInput
  ) => OrderSubscriptionPayloadSubscription;
  phone: (
    where?: PhoneSubscriptionWhereInput
  ) => PhoneSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  purchase: (
    where?: PurchaseSubscriptionWhereInput
  ) => PurchaseSubscriptionPayloadSubscription;
  shipping: (
    where?: ShippingSubscriptionWhereInput
  ) => ShippingSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type PhoneOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "number_ASC"
  | "number_DESC"
  | "type_ASC"
  | "type_DESC"
  | "contact_ASC"
  | "contact_DESC";

export type ShippingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "street_ASC"
  | "street_DESC"
  | "city_ASC"
  | "city_DESC"
  | "state_ASC"
  | "state_DESC"
  | "zipcode_ASC"
  | "zipcode_DESC";

export type BillingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "street_ASC"
  | "street_DESC"
  | "city_ASC"
  | "city_DESC"
  | "state_ASC"
  | "state_DESC"
  | "zipcode_ASC"
  | "zipcode_DESC";

export type PurchaseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "quantity_ASC"
  | "quantity_DESC";

export type OrderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "customer_name_ASC"
  | "customer_name_DESC"
  | "customer_email_ASC"
  | "customer_email_DESC";

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "code_ASC"
  | "code_DESC"
  | "cost_ASC"
  | "cost_DESC"
  | "description_ASC"
  | "description_DESC"
  | "inventory_on_hand_ASC"
  | "inventory_on_hand_DESC"
  | "proeduct_type_ASC"
  | "proeduct_type_DESC"
  | "category_ASC"
  | "category_DESC"
  | "pushed_product_ASC"
  | "pushed_product_DESC"
  | "callback_ASC"
  | "callback_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface ShippingScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  street?: Maybe<String>;
  street_not?: Maybe<String>;
  street_in?: Maybe<String[] | String>;
  street_not_in?: Maybe<String[] | String>;
  street_lt?: Maybe<String>;
  street_lte?: Maybe<String>;
  street_gt?: Maybe<String>;
  street_gte?: Maybe<String>;
  street_contains?: Maybe<String>;
  street_not_contains?: Maybe<String>;
  street_starts_with?: Maybe<String>;
  street_not_starts_with?: Maybe<String>;
  street_ends_with?: Maybe<String>;
  street_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  zipcode?: Maybe<Int>;
  zipcode_not?: Maybe<Int>;
  zipcode_in?: Maybe<Int[] | Int>;
  zipcode_not_in?: Maybe<Int[] | Int>;
  zipcode_lt?: Maybe<Int>;
  zipcode_lte?: Maybe<Int>;
  zipcode_gt?: Maybe<Int>;
  zipcode_gte?: Maybe<Int>;
  AND?: Maybe<ShippingScalarWhereInput[] | ShippingScalarWhereInput>;
  OR?: Maybe<ShippingScalarWhereInput[] | ShippingScalarWhereInput>;
  NOT?: Maybe<ShippingScalarWhereInput[] | ShippingScalarWhereInput>;
}

export type BillingWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PurchaseUpdateWithWhereUniqueWithoutOrder_idInput {
  where: PurchaseWhereUniqueInput;
  data: PurchaseUpdateWithoutOrder_idDataInput;
}

export interface ShippingWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  street?: Maybe<String>;
  street_not?: Maybe<String>;
  street_in?: Maybe<String[] | String>;
  street_not_in?: Maybe<String[] | String>;
  street_lt?: Maybe<String>;
  street_lte?: Maybe<String>;
  street_gt?: Maybe<String>;
  street_gte?: Maybe<String>;
  street_contains?: Maybe<String>;
  street_not_contains?: Maybe<String>;
  street_starts_with?: Maybe<String>;
  street_not_starts_with?: Maybe<String>;
  street_ends_with?: Maybe<String>;
  street_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  zipcode?: Maybe<Int>;
  zipcode_not?: Maybe<Int>;
  zipcode_in?: Maybe<Int[] | Int>;
  zipcode_not_in?: Maybe<Int[] | Int>;
  zipcode_lt?: Maybe<Int>;
  zipcode_lte?: Maybe<Int>;
  zipcode_gt?: Maybe<Int>;
  zipcode_gte?: Maybe<Int>;
  order_id?: Maybe<OrderWhereInput>;
  AND?: Maybe<ShippingWhereInput[] | ShippingWhereInput>;
  OR?: Maybe<ShippingWhereInput[] | ShippingWhereInput>;
  NOT?: Maybe<ShippingWhereInput[] | ShippingWhereInput>;
}

export interface PurchaseUpdateWithoutOrder_idDataInput {
  code?: Maybe<Int>;
  quantity?: Maybe<Int>;
}

export interface PurchaseWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  code?: Maybe<Int>;
  code_not?: Maybe<Int>;
  code_in?: Maybe<Int[] | Int>;
  code_not_in?: Maybe<Int[] | Int>;
  code_lt?: Maybe<Int>;
  code_lte?: Maybe<Int>;
  code_gt?: Maybe<Int>;
  code_gte?: Maybe<Int>;
  quantity?: Maybe<Int>;
  quantity_not?: Maybe<Int>;
  quantity_in?: Maybe<Int[] | Int>;
  quantity_not_in?: Maybe<Int[] | Int>;
  quantity_lt?: Maybe<Int>;
  quantity_lte?: Maybe<Int>;
  quantity_gt?: Maybe<Int>;
  quantity_gte?: Maybe<Int>;
  order_id?: Maybe<OrderWhereInput>;
  AND?: Maybe<PurchaseWhereInput[] | PurchaseWhereInput>;
  OR?: Maybe<PurchaseWhereInput[] | PurchaseWhereInput>;
  NOT?: Maybe<PurchaseWhereInput[] | PurchaseWhereInput>;
}

export interface PurchaseCreateWithoutOrder_idInput {
  id?: Maybe<ID_Input>;
  code: Int;
  quantity: Int;
}

export interface OrderCreateWithoutCustomer_phoneInput {
  id?: Maybe<ID_Input>;
  customer_name: String;
  customer_email: String;
  shipping_address?: Maybe<ShippingCreateManyWithoutOrder_idInput>;
  billing_address?: Maybe<BillingCreateManyWithoutOrder_idInput>;
  purchase_products?: Maybe<PurchaseCreateManyWithoutOrder_idInput>;
}

export interface BillingUpdateInput {
  street?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zipcode?: Maybe<Int>;
  order_id?: Maybe<OrderUpdateOneRequiredWithoutBilling_addressInput>;
}

export interface PurchaseUpsertWithWhereUniqueWithoutOrder_idInput {
  where: PurchaseWhereUniqueInput;
  update: PurchaseUpdateWithoutOrder_idDataInput;
  create: PurchaseCreateWithoutOrder_idInput;
}

export interface OrderUpdateOneRequiredWithoutBilling_addressInput {
  create?: Maybe<OrderCreateWithoutBilling_addressInput>;
  update?: Maybe<OrderUpdateWithoutBilling_addressDataInput>;
  upsert?: Maybe<OrderUpsertWithoutBilling_addressInput>;
  connect?: Maybe<OrderWhereUniqueInput>;
}

export interface PhoneWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  number?: Maybe<Int>;
  number_not?: Maybe<Int>;
  number_in?: Maybe<Int[] | Int>;
  number_not_in?: Maybe<Int[] | Int>;
  number_lt?: Maybe<Int>;
  number_lte?: Maybe<Int>;
  number_gt?: Maybe<Int>;
  number_gte?: Maybe<Int>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  contact?: Maybe<Boolean>;
  contact_not?: Maybe<Boolean>;
  order_id?: Maybe<OrderWhereInput>;
  AND?: Maybe<PhoneWhereInput[] | PhoneWhereInput>;
  OR?: Maybe<PhoneWhereInput[] | PhoneWhereInput>;
  NOT?: Maybe<PhoneWhereInput[] | PhoneWhereInput>;
}

export interface OrderUpdateWithoutBilling_addressDataInput {
  customer_name?: Maybe<String>;
  customer_email?: Maybe<String>;
  customer_phone?: Maybe<PhoneUpdateManyWithoutOrder_idInput>;
  shipping_address?: Maybe<ShippingUpdateManyWithoutOrder_idInput>;
  purchase_products?: Maybe<PurchaseUpdateManyWithoutOrder_idInput>;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductWhereInput>;
  AND?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  OR?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  NOT?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
}

export interface PhoneUpdateManyWithoutOrder_idInput {
  create?: Maybe<
    PhoneCreateWithoutOrder_idInput[] | PhoneCreateWithoutOrder_idInput
  >;
  delete?: Maybe<PhoneWhereUniqueInput[] | PhoneWhereUniqueInput>;
  connect?: Maybe<PhoneWhereUniqueInput[] | PhoneWhereUniqueInput>;
  set?: Maybe<PhoneWhereUniqueInput[] | PhoneWhereUniqueInput>;
  disconnect?: Maybe<PhoneWhereUniqueInput[] | PhoneWhereUniqueInput>;
  update?: Maybe<
    | PhoneUpdateWithWhereUniqueWithoutOrder_idInput[]
    | PhoneUpdateWithWhereUniqueWithoutOrder_idInput
  >;
  upsert?: Maybe<
    | PhoneUpsertWithWhereUniqueWithoutOrder_idInput[]
    | PhoneUpsertWithWhereUniqueWithoutOrder_idInput
  >;
  deleteMany?: Maybe<PhoneScalarWhereInput[] | PhoneScalarWhereInput>;
  updateMany?: Maybe<
    PhoneUpdateManyWithWhereNestedInput[] | PhoneUpdateManyWithWhereNestedInput
  >;
}

export interface OrderSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OrderWhereInput>;
  AND?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
  OR?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
  NOT?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
}

export interface PhoneUpdateWithWhereUniqueWithoutOrder_idInput {
  where: PhoneWhereUniqueInput;
  data: PhoneUpdateWithoutOrder_idDataInput;
}

export interface ShippingUpdateManyMutationInput {
  street?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zipcode?: Maybe<Int>;
}

export interface PhoneUpdateWithoutOrder_idDataInput {
  number?: Maybe<Int>;
  type?: Maybe<String>;
  contact?: Maybe<Boolean>;
}

export interface OrderUpsertWithoutShipping_addressInput {
  update: OrderUpdateWithoutShipping_addressDataInput;
  create: OrderCreateWithoutShipping_addressInput;
}

export interface PhoneUpsertWithWhereUniqueWithoutOrder_idInput {
  where: PhoneWhereUniqueInput;
  update: PhoneUpdateWithoutOrder_idDataInput;
  create: PhoneCreateWithoutOrder_idInput;
}

export interface OrderUpdateOneRequiredWithoutShipping_addressInput {
  create?: Maybe<OrderCreateWithoutShipping_addressInput>;
  update?: Maybe<OrderUpdateWithoutShipping_addressDataInput>;
  upsert?: Maybe<OrderUpsertWithoutShipping_addressInput>;
  connect?: Maybe<OrderWhereUniqueInput>;
}

export interface PhoneScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  number?: Maybe<Int>;
  number_not?: Maybe<Int>;
  number_in?: Maybe<Int[] | Int>;
  number_not_in?: Maybe<Int[] | Int>;
  number_lt?: Maybe<Int>;
  number_lte?: Maybe<Int>;
  number_gt?: Maybe<Int>;
  number_gte?: Maybe<Int>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  contact?: Maybe<Boolean>;
  contact_not?: Maybe<Boolean>;
  AND?: Maybe<PhoneScalarWhereInput[] | PhoneScalarWhereInput>;
  OR?: Maybe<PhoneScalarWhereInput[] | PhoneScalarWhereInput>;
  NOT?: Maybe<PhoneScalarWhereInput[] | PhoneScalarWhereInput>;
}

export type PhoneWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PhoneUpdateManyWithWhereNestedInput {
  where: PhoneScalarWhereInput;
  data: PhoneUpdateManyDataInput;
}

export interface OrderCreateOneWithoutShipping_addressInput {
  create?: Maybe<OrderCreateWithoutShipping_addressInput>;
  connect?: Maybe<OrderWhereUniqueInput>;
}

export interface PhoneUpdateManyDataInput {
  number?: Maybe<Int>;
  type?: Maybe<String>;
  contact?: Maybe<Boolean>;
}

export type ProductWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ShippingUpdateManyWithoutOrder_idInput {
  create?: Maybe<
    ShippingCreateWithoutOrder_idInput[] | ShippingCreateWithoutOrder_idInput
  >;
  delete?: Maybe<ShippingWhereUniqueInput[] | ShippingWhereUniqueInput>;
  connect?: Maybe<ShippingWhereUniqueInput[] | ShippingWhereUniqueInput>;
  set?: Maybe<ShippingWhereUniqueInput[] | ShippingWhereUniqueInput>;
  disconnect?: Maybe<ShippingWhereUniqueInput[] | ShippingWhereUniqueInput>;
  update?: Maybe<
    | ShippingUpdateWithWhereUniqueWithoutOrder_idInput[]
    | ShippingUpdateWithWhereUniqueWithoutOrder_idInput
  >;
  upsert?: Maybe<
    | ShippingUpsertWithWhereUniqueWithoutOrder_idInput[]
    | ShippingUpsertWithWhereUniqueWithoutOrder_idInput
  >;
  deleteMany?: Maybe<ShippingScalarWhereInput[] | ShippingScalarWhereInput>;
  updateMany?: Maybe<
    | ShippingUpdateManyWithWhereNestedInput[]
    | ShippingUpdateManyWithWhereNestedInput
  >;
}

export interface OrderUpsertWithoutPurchase_productsInput {
  update: OrderUpdateWithoutPurchase_productsDataInput;
  create: OrderCreateWithoutPurchase_productsInput;
}

export interface ShippingUpdateWithWhereUniqueWithoutOrder_idInput {
  where: ShippingWhereUniqueInput;
  data: ShippingUpdateWithoutOrder_idDataInput;
}

export interface OrderUpdateWithoutPurchase_productsDataInput {
  customer_name?: Maybe<String>;
  customer_email?: Maybe<String>;
  customer_phone?: Maybe<PhoneUpdateManyWithoutOrder_idInput>;
  shipping_address?: Maybe<ShippingUpdateManyWithoutOrder_idInput>;
  billing_address?: Maybe<BillingUpdateManyWithoutOrder_idInput>;
}

export interface ShippingUpdateWithoutOrder_idDataInput {
  street?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zipcode?: Maybe<Int>;
}

export interface PurchaseUpdateInput {
  code?: Maybe<Int>;
  quantity?: Maybe<Int>;
  order_id?: Maybe<OrderUpdateOneRequiredWithoutPurchase_productsInput>;
}

export interface ShippingUpsertWithWhereUniqueWithoutOrder_idInput {
  where: ShippingWhereUniqueInput;
  update: ShippingUpdateWithoutOrder_idDataInput;
  create: ShippingCreateWithoutOrder_idInput;
}

export type PurchaseWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface OrderUpsertWithoutCustomer_phoneInput {
  update: OrderUpdateWithoutCustomer_phoneDataInput;
  create: OrderCreateWithoutCustomer_phoneInput;
}

export interface PurchaseCreateInput {
  id?: Maybe<ID_Input>;
  code: Int;
  quantity: Int;
  order_id: OrderCreateOneWithoutPurchase_productsInput;
}

export interface ShippingUpdateManyWithWhereNestedInput {
  where: ShippingScalarWhereInput;
  data: ShippingUpdateManyDataInput;
}

export type ShippingWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ShippingUpdateManyDataInput {
  street?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zipcode?: Maybe<Int>;
}

export interface ProductCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  code: Int;
  cost: Float;
  description: String;
  inventory_on_hand: Int;
  proeduct_type: String;
  category: String;
  pushed_product: Boolean;
  callback: String;
}

export interface PurchaseUpdateManyWithoutOrder_idInput {
  create?: Maybe<
    PurchaseCreateWithoutOrder_idInput[] | PurchaseCreateWithoutOrder_idInput
  >;
  delete?: Maybe<PurchaseWhereUniqueInput[] | PurchaseWhereUniqueInput>;
  connect?: Maybe<PurchaseWhereUniqueInput[] | PurchaseWhereUniqueInput>;
  set?: Maybe<PurchaseWhereUniqueInput[] | PurchaseWhereUniqueInput>;
  disconnect?: Maybe<PurchaseWhereUniqueInput[] | PurchaseWhereUniqueInput>;
  update?: Maybe<
    | PurchaseUpdateWithWhereUniqueWithoutOrder_idInput[]
    | PurchaseUpdateWithWhereUniqueWithoutOrder_idInput
  >;
  upsert?: Maybe<
    | PurchaseUpsertWithWhereUniqueWithoutOrder_idInput[]
    | PurchaseUpsertWithWhereUniqueWithoutOrder_idInput
  >;
  deleteMany?: Maybe<PurchaseScalarWhereInput[] | PurchaseScalarWhereInput>;
  updateMany?: Maybe<
    | PurchaseUpdateManyWithWhereNestedInput[]
    | PurchaseUpdateManyWithWhereNestedInput
  >;
}

export interface OrderCreateOneWithoutBilling_addressInput {
  create?: Maybe<OrderCreateWithoutBilling_addressInput>;
  connect?: Maybe<OrderWhereUniqueInput>;
}

export interface BillingWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  street?: Maybe<String>;
  street_not?: Maybe<String>;
  street_in?: Maybe<String[] | String>;
  street_not_in?: Maybe<String[] | String>;
  street_lt?: Maybe<String>;
  street_lte?: Maybe<String>;
  street_gt?: Maybe<String>;
  street_gte?: Maybe<String>;
  street_contains?: Maybe<String>;
  street_not_contains?: Maybe<String>;
  street_starts_with?: Maybe<String>;
  street_not_starts_with?: Maybe<String>;
  street_ends_with?: Maybe<String>;
  street_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  zipcode?: Maybe<Int>;
  zipcode_not?: Maybe<Int>;
  zipcode_in?: Maybe<Int[] | Int>;
  zipcode_not_in?: Maybe<Int[] | Int>;
  zipcode_lt?: Maybe<Int>;
  zipcode_lte?: Maybe<Int>;
  zipcode_gt?: Maybe<Int>;
  zipcode_gte?: Maybe<Int>;
  order_id?: Maybe<OrderWhereInput>;
  AND?: Maybe<BillingWhereInput[] | BillingWhereInput>;
  OR?: Maybe<BillingWhereInput[] | BillingWhereInput>;
  NOT?: Maybe<BillingWhereInput[] | BillingWhereInput>;
}

export interface PhoneCreateManyWithoutOrder_idInput {
  create?: Maybe<
    PhoneCreateWithoutOrder_idInput[] | PhoneCreateWithoutOrder_idInput
  >;
  connect?: Maybe<PhoneWhereUniqueInput[] | PhoneWhereUniqueInput>;
}

export interface OrderWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  customer_name?: Maybe<String>;
  customer_name_not?: Maybe<String>;
  customer_name_in?: Maybe<String[] | String>;
  customer_name_not_in?: Maybe<String[] | String>;
  customer_name_lt?: Maybe<String>;
  customer_name_lte?: Maybe<String>;
  customer_name_gt?: Maybe<String>;
  customer_name_gte?: Maybe<String>;
  customer_name_contains?: Maybe<String>;
  customer_name_not_contains?: Maybe<String>;
  customer_name_starts_with?: Maybe<String>;
  customer_name_not_starts_with?: Maybe<String>;
  customer_name_ends_with?: Maybe<String>;
  customer_name_not_ends_with?: Maybe<String>;
  customer_email?: Maybe<String>;
  customer_email_not?: Maybe<String>;
  customer_email_in?: Maybe<String[] | String>;
  customer_email_not_in?: Maybe<String[] | String>;
  customer_email_lt?: Maybe<String>;
  customer_email_lte?: Maybe<String>;
  customer_email_gt?: Maybe<String>;
  customer_email_gte?: Maybe<String>;
  customer_email_contains?: Maybe<String>;
  customer_email_not_contains?: Maybe<String>;
  customer_email_starts_with?: Maybe<String>;
  customer_email_not_starts_with?: Maybe<String>;
  customer_email_ends_with?: Maybe<String>;
  customer_email_not_ends_with?: Maybe<String>;
  customer_phone_every?: Maybe<PhoneWhereInput>;
  customer_phone_some?: Maybe<PhoneWhereInput>;
  customer_phone_none?: Maybe<PhoneWhereInput>;
  shipping_address_every?: Maybe<ShippingWhereInput>;
  shipping_address_some?: Maybe<ShippingWhereInput>;
  shipping_address_none?: Maybe<ShippingWhereInput>;
  billing_address_every?: Maybe<BillingWhereInput>;
  billing_address_some?: Maybe<BillingWhereInput>;
  billing_address_none?: Maybe<BillingWhereInput>;
  purchase_products_every?: Maybe<PurchaseWhereInput>;
  purchase_products_some?: Maybe<PurchaseWhereInput>;
  purchase_products_none?: Maybe<PurchaseWhereInput>;
  AND?: Maybe<OrderWhereInput[] | OrderWhereInput>;
  OR?: Maybe<OrderWhereInput[] | OrderWhereInput>;
  NOT?: Maybe<OrderWhereInput[] | OrderWhereInput>;
}

export interface ShippingCreateManyWithoutOrder_idInput {
  create?: Maybe<
    ShippingCreateWithoutOrder_idInput[] | ShippingCreateWithoutOrder_idInput
  >;
  connect?: Maybe<ShippingWhereUniqueInput[] | ShippingWhereUniqueInput>;
}

export interface OrderUpdateWithoutCustomer_phoneDataInput {
  customer_name?: Maybe<String>;
  customer_email?: Maybe<String>;
  shipping_address?: Maybe<ShippingUpdateManyWithoutOrder_idInput>;
  billing_address?: Maybe<BillingUpdateManyWithoutOrder_idInput>;
  purchase_products?: Maybe<PurchaseUpdateManyWithoutOrder_idInput>;
}

export interface PurchaseCreateManyWithoutOrder_idInput {
  create?: Maybe<
    PurchaseCreateWithoutOrder_idInput[] | PurchaseCreateWithoutOrder_idInput
  >;
  connect?: Maybe<PurchaseWhereUniqueInput[] | PurchaseWhereUniqueInput>;
}

export interface PurchaseScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  code?: Maybe<Int>;
  code_not?: Maybe<Int>;
  code_in?: Maybe<Int[] | Int>;
  code_not_in?: Maybe<Int[] | Int>;
  code_lt?: Maybe<Int>;
  code_lte?: Maybe<Int>;
  code_gt?: Maybe<Int>;
  code_gte?: Maybe<Int>;
  quantity?: Maybe<Int>;
  quantity_not?: Maybe<Int>;
  quantity_in?: Maybe<Int[] | Int>;
  quantity_not_in?: Maybe<Int[] | Int>;
  quantity_lt?: Maybe<Int>;
  quantity_lte?: Maybe<Int>;
  quantity_gt?: Maybe<Int>;
  quantity_gte?: Maybe<Int>;
  AND?: Maybe<PurchaseScalarWhereInput[] | PurchaseScalarWhereInput>;
  OR?: Maybe<PurchaseScalarWhereInput[] | PurchaseScalarWhereInput>;
  NOT?: Maybe<PurchaseScalarWhereInput[] | PurchaseScalarWhereInput>;
}

export interface PurchaseSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PurchaseWhereInput>;
  AND?: Maybe<
    PurchaseSubscriptionWhereInput[] | PurchaseSubscriptionWhereInput
  >;
  OR?: Maybe<PurchaseSubscriptionWhereInput[] | PurchaseSubscriptionWhereInput>;
  NOT?: Maybe<
    PurchaseSubscriptionWhereInput[] | PurchaseSubscriptionWhereInput
  >;
}

export interface PurchaseUpdateManyWithWhereNestedInput {
  where: PurchaseScalarWhereInput;
  data: PurchaseUpdateManyDataInput;
}

export interface BillingSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BillingWhereInput>;
  AND?: Maybe<BillingSubscriptionWhereInput[] | BillingSubscriptionWhereInput>;
  OR?: Maybe<BillingSubscriptionWhereInput[] | BillingSubscriptionWhereInput>;
  NOT?: Maybe<BillingSubscriptionWhereInput[] | BillingSubscriptionWhereInput>;
}

export interface PurchaseUpdateManyDataInput {
  code?: Maybe<Int>;
  quantity?: Maybe<Int>;
}

export interface OrderUpdateWithoutShipping_addressDataInput {
  customer_name?: Maybe<String>;
  customer_email?: Maybe<String>;
  customer_phone?: Maybe<PhoneUpdateManyWithoutOrder_idInput>;
  billing_address?: Maybe<BillingUpdateManyWithoutOrder_idInput>;
  purchase_products?: Maybe<PurchaseUpdateManyWithoutOrder_idInput>;
}

export interface OrderUpsertWithoutBilling_addressInput {
  update: OrderUpdateWithoutBilling_addressDataInput;
  create: OrderCreateWithoutBilling_addressInput;
}

export interface OrderCreateWithoutShipping_addressInput {
  id?: Maybe<ID_Input>;
  customer_name: String;
  customer_email: String;
  customer_phone?: Maybe<PhoneCreateManyWithoutOrder_idInput>;
  billing_address?: Maybe<BillingCreateManyWithoutOrder_idInput>;
  purchase_products?: Maybe<PurchaseCreateManyWithoutOrder_idInput>;
}

export interface BillingUpdateManyMutationInput {
  street?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zipcode?: Maybe<Int>;
}

export interface PurchaseUpdateManyMutationInput {
  code?: Maybe<Int>;
  quantity?: Maybe<Int>;
}

export interface OrderUpdateOneRequiredWithoutCustomer_phoneInput {
  create?: Maybe<OrderCreateWithoutCustomer_phoneInput>;
  update?: Maybe<OrderUpdateWithoutCustomer_phoneDataInput>;
  upsert?: Maybe<OrderUpsertWithoutCustomer_phoneInput>;
  connect?: Maybe<OrderWhereUniqueInput>;
}

export interface OrderUpdateOneRequiredWithoutPurchase_productsInput {
  create?: Maybe<OrderCreateWithoutPurchase_productsInput>;
  update?: Maybe<OrderUpdateWithoutPurchase_productsDataInput>;
  upsert?: Maybe<OrderUpsertWithoutPurchase_productsInput>;
  connect?: Maybe<OrderWhereUniqueInput>;
}

export interface PhoneUpdateInput {
  number?: Maybe<Int>;
  type?: Maybe<String>;
  contact?: Maybe<Boolean>;
  order_id?: Maybe<OrderUpdateOneRequiredWithoutCustomer_phoneInput>;
}

export interface OrderCreateOneWithoutPurchase_productsInput {
  create?: Maybe<OrderCreateWithoutPurchase_productsInput>;
  connect?: Maybe<OrderWhereUniqueInput>;
}

export interface OrderCreateInput {
  id?: Maybe<ID_Input>;
  customer_name: String;
  customer_email: String;
  customer_phone?: Maybe<PhoneCreateManyWithoutOrder_idInput>;
  shipping_address?: Maybe<ShippingCreateManyWithoutOrder_idInput>;
  billing_address?: Maybe<BillingCreateManyWithoutOrder_idInput>;
  purchase_products?: Maybe<PurchaseCreateManyWithoutOrder_idInput>;
}

export interface ProductUpdateInput {
  name?: Maybe<String>;
  code?: Maybe<Int>;
  cost?: Maybe<Float>;
  description?: Maybe<String>;
  inventory_on_hand?: Maybe<Int>;
  proeduct_type?: Maybe<String>;
  category?: Maybe<String>;
  pushed_product?: Maybe<Boolean>;
  callback?: Maybe<String>;
}

export interface BillingCreateManyWithoutOrder_idInput {
  create?: Maybe<
    BillingCreateWithoutOrder_idInput[] | BillingCreateWithoutOrder_idInput
  >;
  connect?: Maybe<BillingWhereUniqueInput[] | BillingWhereUniqueInput>;
}

export interface BillingCreateInput {
  id?: Maybe<ID_Input>;
  street: String;
  city: String;
  state: String;
  zipcode: Int;
  order_id: OrderCreateOneWithoutBilling_addressInput;
}

export interface BillingCreateWithoutOrder_idInput {
  id?: Maybe<ID_Input>;
  street: String;
  city: String;
  state: String;
  zipcode: Int;
}

export interface PhoneCreateWithoutOrder_idInput {
  id?: Maybe<ID_Input>;
  number: Int;
  type: String;
  contact: Boolean;
}

export interface OrderUpdateInput {
  customer_name?: Maybe<String>;
  customer_email?: Maybe<String>;
  customer_phone?: Maybe<PhoneUpdateManyWithoutOrder_idInput>;
  shipping_address?: Maybe<ShippingUpdateManyWithoutOrder_idInput>;
  billing_address?: Maybe<BillingUpdateManyWithoutOrder_idInput>;
  purchase_products?: Maybe<PurchaseUpdateManyWithoutOrder_idInput>;
}

export interface ShippingSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ShippingWhereInput>;
  AND?: Maybe<
    ShippingSubscriptionWhereInput[] | ShippingSubscriptionWhereInput
  >;
  OR?: Maybe<ShippingSubscriptionWhereInput[] | ShippingSubscriptionWhereInput>;
  NOT?: Maybe<
    ShippingSubscriptionWhereInput[] | ShippingSubscriptionWhereInput
  >;
}

export interface BillingUpdateManyWithoutOrder_idInput {
  create?: Maybe<
    BillingCreateWithoutOrder_idInput[] | BillingCreateWithoutOrder_idInput
  >;
  delete?: Maybe<BillingWhereUniqueInput[] | BillingWhereUniqueInput>;
  connect?: Maybe<BillingWhereUniqueInput[] | BillingWhereUniqueInput>;
  set?: Maybe<BillingWhereUniqueInput[] | BillingWhereUniqueInput>;
  disconnect?: Maybe<BillingWhereUniqueInput[] | BillingWhereUniqueInput>;
  update?: Maybe<
    | BillingUpdateWithWhereUniqueWithoutOrder_idInput[]
    | BillingUpdateWithWhereUniqueWithoutOrder_idInput
  >;
  upsert?: Maybe<
    | BillingUpsertWithWhereUniqueWithoutOrder_idInput[]
    | BillingUpsertWithWhereUniqueWithoutOrder_idInput
  >;
  deleteMany?: Maybe<BillingScalarWhereInput[] | BillingScalarWhereInput>;
  updateMany?: Maybe<
    | BillingUpdateManyWithWhereNestedInput[]
    | BillingUpdateManyWithWhereNestedInput
  >;
}

export type OrderWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BillingUpdateWithWhereUniqueWithoutOrder_idInput {
  where: BillingWhereUniqueInput;
  data: BillingUpdateWithoutOrder_idDataInput;
}

export interface ShippingCreateInput {
  id?: Maybe<ID_Input>;
  street: String;
  city: String;
  state: String;
  zipcode: Int;
  order_id: OrderCreateOneWithoutShipping_addressInput;
}

export interface BillingUpdateWithoutOrder_idDataInput {
  street?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zipcode?: Maybe<Int>;
}

export interface OrderCreateWithoutPurchase_productsInput {
  id?: Maybe<ID_Input>;
  customer_name: String;
  customer_email: String;
  customer_phone?: Maybe<PhoneCreateManyWithoutOrder_idInput>;
  shipping_address?: Maybe<ShippingCreateManyWithoutOrder_idInput>;
  billing_address?: Maybe<BillingCreateManyWithoutOrder_idInput>;
}

export interface BillingUpsertWithWhereUniqueWithoutOrder_idInput {
  where: BillingWhereUniqueInput;
  update: BillingUpdateWithoutOrder_idDataInput;
  create: BillingCreateWithoutOrder_idInput;
}

export interface PhoneUpdateManyMutationInput {
  number?: Maybe<Int>;
  type?: Maybe<String>;
  contact?: Maybe<Boolean>;
}

export interface BillingScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  street?: Maybe<String>;
  street_not?: Maybe<String>;
  street_in?: Maybe<String[] | String>;
  street_not_in?: Maybe<String[] | String>;
  street_lt?: Maybe<String>;
  street_lte?: Maybe<String>;
  street_gt?: Maybe<String>;
  street_gte?: Maybe<String>;
  street_contains?: Maybe<String>;
  street_not_contains?: Maybe<String>;
  street_starts_with?: Maybe<String>;
  street_not_starts_with?: Maybe<String>;
  street_ends_with?: Maybe<String>;
  street_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  zipcode?: Maybe<Int>;
  zipcode_not?: Maybe<Int>;
  zipcode_in?: Maybe<Int[] | Int>;
  zipcode_not_in?: Maybe<Int[] | Int>;
  zipcode_lt?: Maybe<Int>;
  zipcode_lte?: Maybe<Int>;
  zipcode_gt?: Maybe<Int>;
  zipcode_gte?: Maybe<Int>;
  AND?: Maybe<BillingScalarWhereInput[] | BillingScalarWhereInput>;
  OR?: Maybe<BillingScalarWhereInput[] | BillingScalarWhereInput>;
  NOT?: Maybe<BillingScalarWhereInput[] | BillingScalarWhereInput>;
}

export interface ShippingCreateWithoutOrder_idInput {
  id?: Maybe<ID_Input>;
  street: String;
  city: String;
  state: String;
  zipcode: Int;
}

export interface BillingUpdateManyWithWhereNestedInput {
  where: BillingScalarWhereInput;
  data: BillingUpdateManyDataInput;
}

export interface ShippingUpdateInput {
  street?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zipcode?: Maybe<Int>;
  order_id?: Maybe<OrderUpdateOneRequiredWithoutShipping_addressInput>;
}

export interface OrderCreateOneWithoutCustomer_phoneInput {
  create?: Maybe<OrderCreateWithoutCustomer_phoneInput>;
  connect?: Maybe<OrderWhereUniqueInput>;
}

export interface PhoneCreateInput {
  id?: Maybe<ID_Input>;
  number: Int;
  type: String;
  contact: Boolean;
  order_id: OrderCreateOneWithoutCustomer_phoneInput;
}

export interface OrderUpdateManyMutationInput {
  customer_name?: Maybe<String>;
  customer_email?: Maybe<String>;
}

export interface BillingUpdateManyDataInput {
  street?: Maybe<String>;
  city?: Maybe<String>;
  state?: Maybe<String>;
  zipcode?: Maybe<Int>;
}

export interface ProductWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  code?: Maybe<Int>;
  code_not?: Maybe<Int>;
  code_in?: Maybe<Int[] | Int>;
  code_not_in?: Maybe<Int[] | Int>;
  code_lt?: Maybe<Int>;
  code_lte?: Maybe<Int>;
  code_gt?: Maybe<Int>;
  code_gte?: Maybe<Int>;
  cost?: Maybe<Float>;
  cost_not?: Maybe<Float>;
  cost_in?: Maybe<Float[] | Float>;
  cost_not_in?: Maybe<Float[] | Float>;
  cost_lt?: Maybe<Float>;
  cost_lte?: Maybe<Float>;
  cost_gt?: Maybe<Float>;
  cost_gte?: Maybe<Float>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  inventory_on_hand?: Maybe<Int>;
  inventory_on_hand_not?: Maybe<Int>;
  inventory_on_hand_in?: Maybe<Int[] | Int>;
  inventory_on_hand_not_in?: Maybe<Int[] | Int>;
  inventory_on_hand_lt?: Maybe<Int>;
  inventory_on_hand_lte?: Maybe<Int>;
  inventory_on_hand_gt?: Maybe<Int>;
  inventory_on_hand_gte?: Maybe<Int>;
  proeduct_type?: Maybe<String>;
  proeduct_type_not?: Maybe<String>;
  proeduct_type_in?: Maybe<String[] | String>;
  proeduct_type_not_in?: Maybe<String[] | String>;
  proeduct_type_lt?: Maybe<String>;
  proeduct_type_lte?: Maybe<String>;
  proeduct_type_gt?: Maybe<String>;
  proeduct_type_gte?: Maybe<String>;
  proeduct_type_contains?: Maybe<String>;
  proeduct_type_not_contains?: Maybe<String>;
  proeduct_type_starts_with?: Maybe<String>;
  proeduct_type_not_starts_with?: Maybe<String>;
  proeduct_type_ends_with?: Maybe<String>;
  proeduct_type_not_ends_with?: Maybe<String>;
  category?: Maybe<String>;
  category_not?: Maybe<String>;
  category_in?: Maybe<String[] | String>;
  category_not_in?: Maybe<String[] | String>;
  category_lt?: Maybe<String>;
  category_lte?: Maybe<String>;
  category_gt?: Maybe<String>;
  category_gte?: Maybe<String>;
  category_contains?: Maybe<String>;
  category_not_contains?: Maybe<String>;
  category_starts_with?: Maybe<String>;
  category_not_starts_with?: Maybe<String>;
  category_ends_with?: Maybe<String>;
  category_not_ends_with?: Maybe<String>;
  pushed_product?: Maybe<Boolean>;
  pushed_product_not?: Maybe<Boolean>;
  callback?: Maybe<String>;
  callback_not?: Maybe<String>;
  callback_in?: Maybe<String[] | String>;
  callback_not_in?: Maybe<String[] | String>;
  callback_lt?: Maybe<String>;
  callback_lte?: Maybe<String>;
  callback_gt?: Maybe<String>;
  callback_gte?: Maybe<String>;
  callback_contains?: Maybe<String>;
  callback_not_contains?: Maybe<String>;
  callback_starts_with?: Maybe<String>;
  callback_not_starts_with?: Maybe<String>;
  callback_ends_with?: Maybe<String>;
  callback_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  OR?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  NOT?: Maybe<ProductWhereInput[] | ProductWhereInput>;
}

export interface PhoneSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PhoneWhereInput>;
  AND?: Maybe<PhoneSubscriptionWhereInput[] | PhoneSubscriptionWhereInput>;
  OR?: Maybe<PhoneSubscriptionWhereInput[] | PhoneSubscriptionWhereInput>;
  NOT?: Maybe<PhoneSubscriptionWhereInput[] | PhoneSubscriptionWhereInput>;
}

export interface OrderCreateWithoutBilling_addressInput {
  id?: Maybe<ID_Input>;
  customer_name: String;
  customer_email: String;
  customer_phone?: Maybe<PhoneCreateManyWithoutOrder_idInput>;
  shipping_address?: Maybe<ShippingCreateManyWithoutOrder_idInput>;
  purchase_products?: Maybe<PurchaseCreateManyWithoutOrder_idInput>;
}

export interface ProductUpdateManyMutationInput {
  name?: Maybe<String>;
  code?: Maybe<Int>;
  cost?: Maybe<Float>;
  description?: Maybe<String>;
  inventory_on_hand?: Maybe<Int>;
  proeduct_type?: Maybe<String>;
  category?: Maybe<String>;
  pushed_product?: Maybe<Boolean>;
  callback?: Maybe<String>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface ShippingPreviousValues {
  id: ID_Output;
  street: String;
  city: String;
  state: String;
  zipcode: Int;
}

export interface ShippingPreviousValuesPromise
  extends Promise<ShippingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  street: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zipcode: () => Promise<Int>;
}

export interface ShippingPreviousValuesSubscription
  extends Promise<AsyncIterator<ShippingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  street: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zipcode: () => Promise<AsyncIterator<Int>>;
}

export interface OrderConnection {
  pageInfo: PageInfo;
  edges: OrderEdge[];
}

export interface OrderConnectionPromise
  extends Promise<OrderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderEdge>>() => T;
  aggregate: <T = AggregateOrderPromise>() => T;
}

export interface OrderConnectionSubscription
  extends Promise<AsyncIterator<OrderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderSubscription>() => T;
}

export interface Phone {
  id: ID_Output;
  number: Int;
  type: String;
  contact: Boolean;
}

export interface PhonePromise extends Promise<Phone>, Fragmentable {
  id: () => Promise<ID_Output>;
  number: () => Promise<Int>;
  type: () => Promise<String>;
  contact: () => Promise<Boolean>;
  order_id: <T = OrderPromise>() => T;
}

export interface PhoneSubscription
  extends Promise<AsyncIterator<Phone>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  number: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<String>>;
  contact: () => Promise<AsyncIterator<Boolean>>;
  order_id: <T = OrderSubscription>() => T;
}

export interface PhoneNullablePromise
  extends Promise<Phone | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  number: () => Promise<Int>;
  type: () => Promise<String>;
  contact: () => Promise<Boolean>;
  order_id: <T = OrderPromise>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface PurchaseSubscriptionPayload {
  mutation: MutationType;
  node: Purchase;
  updatedFields: String[];
  previousValues: PurchasePreviousValues;
}

export interface PurchaseSubscriptionPayloadPromise
  extends Promise<PurchaseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PurchasePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PurchasePreviousValuesPromise>() => T;
}

export interface PurchaseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PurchaseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PurchaseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PurchasePreviousValuesSubscription>() => T;
}

export interface PurchasePreviousValues {
  id: ID_Output;
  code: Int;
  quantity: Int;
}

export interface PurchasePreviousValuesPromise
  extends Promise<PurchasePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<Int>;
  quantity: () => Promise<Int>;
}

export interface PurchasePreviousValuesSubscription
  extends Promise<AsyncIterator<PurchasePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<Int>>;
  quantity: () => Promise<AsyncIterator<Int>>;
}

export interface ShippingEdge {
  node: Shipping;
  cursor: String;
}

export interface ShippingEdgePromise
  extends Promise<ShippingEdge>,
    Fragmentable {
  node: <T = ShippingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ShippingEdgeSubscription
  extends Promise<AsyncIterator<ShippingEdge>>,
    Fragmentable {
  node: <T = ShippingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBilling {
  count: Int;
}

export interface AggregateBillingPromise
  extends Promise<AggregateBilling>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBillingSubscription
  extends Promise<AsyncIterator<AggregateBilling>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregatePurchase {
  count: Int;
}

export interface AggregatePurchasePromise
  extends Promise<AggregatePurchase>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePurchaseSubscription
  extends Promise<AsyncIterator<AggregatePurchase>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BillingEdge {
  node: Billing;
  cursor: String;
}

export interface BillingEdgePromise extends Promise<BillingEdge>, Fragmentable {
  node: <T = BillingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BillingEdgeSubscription
  extends Promise<AsyncIterator<BillingEdge>>,
    Fragmentable {
  node: <T = BillingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PurchaseConnection {
  pageInfo: PageInfo;
  edges: PurchaseEdge[];
}

export interface PurchaseConnectionPromise
  extends Promise<PurchaseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PurchaseEdge>>() => T;
  aggregate: <T = AggregatePurchasePromise>() => T;
}

export interface PurchaseConnectionSubscription
  extends Promise<AsyncIterator<PurchaseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PurchaseEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePurchaseSubscription>() => T;
}

export interface Billing {
  id: ID_Output;
  street: String;
  city: String;
  state: String;
  zipcode: Int;
}

export interface BillingPromise extends Promise<Billing>, Fragmentable {
  id: () => Promise<ID_Output>;
  street: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zipcode: () => Promise<Int>;
  order_id: <T = OrderPromise>() => T;
}

export interface BillingSubscription
  extends Promise<AsyncIterator<Billing>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  street: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zipcode: () => Promise<AsyncIterator<Int>>;
  order_id: <T = OrderSubscription>() => T;
}

export interface BillingNullablePromise
  extends Promise<Billing | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  street: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zipcode: () => Promise<Int>;
  order_id: <T = OrderPromise>() => T;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BillingSubscriptionPayload {
  mutation: MutationType;
  node: Billing;
  updatedFields: String[];
  previousValues: BillingPreviousValues;
}

export interface BillingSubscriptionPayloadPromise
  extends Promise<BillingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BillingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BillingPreviousValuesPromise>() => T;
}

export interface BillingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BillingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BillingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BillingPreviousValuesSubscription>() => T;
}

export interface ShippingSubscriptionPayload {
  mutation: MutationType;
  node: Shipping;
  updatedFields: String[];
  previousValues: ShippingPreviousValues;
}

export interface ShippingSubscriptionPayloadPromise
  extends Promise<ShippingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ShippingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ShippingPreviousValuesPromise>() => T;
}

export interface ShippingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ShippingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ShippingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ShippingPreviousValuesSubscription>() => T;
}

export interface BillingPreviousValues {
  id: ID_Output;
  street: String;
  city: String;
  state: String;
  zipcode: Int;
}

export interface BillingPreviousValuesPromise
  extends Promise<BillingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  street: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zipcode: () => Promise<Int>;
}

export interface BillingPreviousValuesSubscription
  extends Promise<AsyncIterator<BillingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  street: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zipcode: () => Promise<AsyncIterator<Int>>;
}

export interface Product {
  id: ID_Output;
  name: String;
  code: Int;
  cost: Float;
  description: String;
  inventory_on_hand: Int;
  proeduct_type: String;
  category: String;
  pushed_product: Boolean;
  callback: String;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  code: () => Promise<Int>;
  cost: () => Promise<Float>;
  description: () => Promise<String>;
  inventory_on_hand: () => Promise<Int>;
  proeduct_type: () => Promise<String>;
  category: () => Promise<String>;
  pushed_product: () => Promise<Boolean>;
  callback: () => Promise<String>;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<Int>>;
  cost: () => Promise<AsyncIterator<Float>>;
  description: () => Promise<AsyncIterator<String>>;
  inventory_on_hand: () => Promise<AsyncIterator<Int>>;
  proeduct_type: () => Promise<AsyncIterator<String>>;
  category: () => Promise<AsyncIterator<String>>;
  pushed_product: () => Promise<AsyncIterator<Boolean>>;
  callback: () => Promise<AsyncIterator<String>>;
}

export interface ProductNullablePromise
  extends Promise<Product | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  code: () => Promise<Int>;
  cost: () => Promise<Float>;
  description: () => Promise<String>;
  inventory_on_hand: () => Promise<Int>;
  proeduct_type: () => Promise<String>;
  category: () => Promise<String>;
  pushed_product: () => Promise<Boolean>;
  callback: () => Promise<String>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface PhoneEdge {
  node: Phone;
  cursor: String;
}

export interface PhoneEdgePromise extends Promise<PhoneEdge>, Fragmentable {
  node: <T = PhonePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PhoneEdgeSubscription
  extends Promise<AsyncIterator<PhoneEdge>>,
    Fragmentable {
  node: <T = PhoneSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface OrderSubscriptionPayload {
  mutation: MutationType;
  node: Order;
  updatedFields: String[];
  previousValues: OrderPreviousValues;
}

export interface OrderSubscriptionPayloadPromise
  extends Promise<OrderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderPreviousValuesPromise>() => T;
}

export interface OrderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderPreviousValuesSubscription>() => T;
}

export interface AggregateOrder {
  count: Int;
}

export interface AggregateOrderPromise
  extends Promise<AggregateOrder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderSubscription
  extends Promise<AsyncIterator<AggregateOrder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrderPreviousValues {
  id: ID_Output;
  customer_name: String;
  customer_email: String;
}

export interface OrderPreviousValuesPromise
  extends Promise<OrderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  customer_name: () => Promise<String>;
  customer_email: () => Promise<String>;
}

export interface OrderPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  customer_name: () => Promise<AsyncIterator<String>>;
  customer_email: () => Promise<AsyncIterator<String>>;
}

export interface AggregateShipping {
  count: Int;
}

export interface AggregateShippingPromise
  extends Promise<AggregateShipping>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateShippingSubscription
  extends Promise<AsyncIterator<AggregateShipping>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BillingConnection {
  pageInfo: PageInfo;
  edges: BillingEdge[];
}

export interface BillingConnectionPromise
  extends Promise<BillingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BillingEdge>>() => T;
  aggregate: <T = AggregateBillingPromise>() => T;
}

export interface BillingConnectionSubscription
  extends Promise<AsyncIterator<BillingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BillingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBillingSubscription>() => T;
}

export interface PurchaseEdge {
  node: Purchase;
  cursor: String;
}

export interface PurchaseEdgePromise
  extends Promise<PurchaseEdge>,
    Fragmentable {
  node: <T = PurchasePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PurchaseEdgeSubscription
  extends Promise<AsyncIterator<PurchaseEdge>>,
    Fragmentable {
  node: <T = PurchaseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PhoneSubscriptionPayload {
  mutation: MutationType;
  node: Phone;
  updatedFields: String[];
  previousValues: PhonePreviousValues;
}

export interface PhoneSubscriptionPayloadPromise
  extends Promise<PhoneSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PhonePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PhonePreviousValuesPromise>() => T;
}

export interface PhoneSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PhoneSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PhoneSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PhonePreviousValuesSubscription>() => T;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface PhonePreviousValues {
  id: ID_Output;
  number: Int;
  type: String;
  contact: Boolean;
}

export interface PhonePreviousValuesPromise
  extends Promise<PhonePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  number: () => Promise<Int>;
  type: () => Promise<String>;
  contact: () => Promise<Boolean>;
}

export interface PhonePreviousValuesSubscription
  extends Promise<AsyncIterator<PhonePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  number: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<String>>;
  contact: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregatePhone {
  count: Int;
}

export interface AggregatePhonePromise
  extends Promise<AggregatePhone>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePhoneSubscription
  extends Promise<AsyncIterator<AggregatePhone>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Order {
  id: ID_Output;
  customer_name: String;
  customer_email: String;
}

export interface OrderPromise extends Promise<Order>, Fragmentable {
  id: () => Promise<ID_Output>;
  customer_name: () => Promise<String>;
  customer_email: () => Promise<String>;
  customer_phone: <T = FragmentableArray<Phone>>(args?: {
    where?: PhoneWhereInput;
    orderBy?: PhoneOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  shipping_address: <T = FragmentableArray<Shipping>>(args?: {
    where?: ShippingWhereInput;
    orderBy?: ShippingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  billing_address: <T = FragmentableArray<Billing>>(args?: {
    where?: BillingWhereInput;
    orderBy?: BillingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  purchase_products: <T = FragmentableArray<Purchase>>(args?: {
    where?: PurchaseWhereInput;
    orderBy?: PurchaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface OrderSubscription
  extends Promise<AsyncIterator<Order>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  customer_name: () => Promise<AsyncIterator<String>>;
  customer_email: () => Promise<AsyncIterator<String>>;
  customer_phone: <T = Promise<AsyncIterator<PhoneSubscription>>>(args?: {
    where?: PhoneWhereInput;
    orderBy?: PhoneOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  shipping_address: <T = Promise<AsyncIterator<ShippingSubscription>>>(args?: {
    where?: ShippingWhereInput;
    orderBy?: ShippingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  billing_address: <T = Promise<AsyncIterator<BillingSubscription>>>(args?: {
    where?: BillingWhereInput;
    orderBy?: BillingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  purchase_products: <T = Promise<AsyncIterator<PurchaseSubscription>>>(args?: {
    where?: PurchaseWhereInput;
    orderBy?: PurchaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface OrderNullablePromise
  extends Promise<Order | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  customer_name: () => Promise<String>;
  customer_email: () => Promise<String>;
  customer_phone: <T = FragmentableArray<Phone>>(args?: {
    where?: PhoneWhereInput;
    orderBy?: PhoneOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  shipping_address: <T = FragmentableArray<Shipping>>(args?: {
    where?: ShippingWhereInput;
    orderBy?: ShippingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  billing_address: <T = FragmentableArray<Billing>>(args?: {
    where?: BillingWhereInput;
    orderBy?: BillingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  purchase_products: <T = FragmentableArray<Purchase>>(args?: {
    where?: PurchaseWhereInput;
    orderBy?: PurchaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductPreviousValues {
  id: ID_Output;
  name: String;
  code: Int;
  cost: Float;
  description: String;
  inventory_on_hand: Int;
  proeduct_type: String;
  category: String;
  pushed_product: Boolean;
  callback: String;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  code: () => Promise<Int>;
  cost: () => Promise<Float>;
  description: () => Promise<String>;
  inventory_on_hand: () => Promise<Int>;
  proeduct_type: () => Promise<String>;
  category: () => Promise<String>;
  pushed_product: () => Promise<Boolean>;
  callback: () => Promise<String>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<Int>>;
  cost: () => Promise<AsyncIterator<Float>>;
  description: () => Promise<AsyncIterator<String>>;
  inventory_on_hand: () => Promise<AsyncIterator<Int>>;
  proeduct_type: () => Promise<AsyncIterator<String>>;
  category: () => Promise<AsyncIterator<String>>;
  pushed_product: () => Promise<AsyncIterator<Boolean>>;
  callback: () => Promise<AsyncIterator<String>>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface Purchase {
  id: ID_Output;
  code: Int;
  quantity: Int;
}

export interface PurchasePromise extends Promise<Purchase>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<Int>;
  quantity: () => Promise<Int>;
  order_id: <T = OrderPromise>() => T;
}

export interface PurchaseSubscription
  extends Promise<AsyncIterator<Purchase>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<Int>>;
  quantity: () => Promise<AsyncIterator<Int>>;
  order_id: <T = OrderSubscription>() => T;
}

export interface PurchaseNullablePromise
  extends Promise<Purchase | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<Int>;
  quantity: () => Promise<Int>;
  order_id: <T = OrderPromise>() => T;
}

export interface PhoneConnection {
  pageInfo: PageInfo;
  edges: PhoneEdge[];
}

export interface PhoneConnectionPromise
  extends Promise<PhoneConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PhoneEdge>>() => T;
  aggregate: <T = AggregatePhonePromise>() => T;
}

export interface PhoneConnectionSubscription
  extends Promise<AsyncIterator<PhoneConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PhoneEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePhoneSubscription>() => T;
}

export interface Shipping {
  id: ID_Output;
  street: String;
  city: String;
  state: String;
  zipcode: Int;
}

export interface ShippingPromise extends Promise<Shipping>, Fragmentable {
  id: () => Promise<ID_Output>;
  street: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zipcode: () => Promise<Int>;
  order_id: <T = OrderPromise>() => T;
}

export interface ShippingSubscription
  extends Promise<AsyncIterator<Shipping>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  street: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String>>;
  zipcode: () => Promise<AsyncIterator<Int>>;
  order_id: <T = OrderSubscription>() => T;
}

export interface ShippingNullablePromise
  extends Promise<Shipping | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  street: () => Promise<String>;
  city: () => Promise<String>;
  state: () => Promise<String>;
  zipcode: () => Promise<Int>;
  order_id: <T = OrderPromise>() => T;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ShippingConnection {
  pageInfo: PageInfo;
  edges: ShippingEdge[];
}

export interface ShippingConnectionPromise
  extends Promise<ShippingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ShippingEdge>>() => T;
  aggregate: <T = AggregateShippingPromise>() => T;
}

export interface ShippingConnectionSubscription
  extends Promise<AsyncIterator<ShippingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ShippingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateShippingSubscription>() => T;
}

export interface OrderEdge {
  node: Order;
  cursor: String;
}

export interface OrderEdgePromise extends Promise<OrderEdge>, Fragmentable {
  node: <T = OrderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderEdgeSubscription
  extends Promise<AsyncIterator<OrderEdge>>,
    Fragmentable {
  node: <T = OrderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

export type Long = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Product",
    embedded: false
  },
  {
    name: "Order",
    embedded: false
  },
  {
    name: "Phone",
    embedded: false
  },
  {
    name: "Shipping",
    embedded: false
  },
  {
    name: "Billing",
    embedded: false
  },
  {
    name: "Purchase",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
